\section{问题提出的背景}

% \par 正文格式与具体要求\cite{zjuthesisrules}

\subsection{背景介绍}

\subsubsection{多处理器调度问题}

多处理器调度问题（Parallel Machine Scheduling Problem）\cite{gary1979computers}
是生产调度领域中的一个经典问题，
它主要关注如何在 $m$ 台相同的机器上合理安排 $n$ 个任务的执行顺序，
以达到某些特定的目标，
比如最小化所有任务完成的时间总和、
最小化最后一个任务的完成时间等。
形式化地，这个问题可以描述为：

\begin{defi}
    \textbf{朴素多处理器调度问题：}一个实例 $I$ 包含一组 $n$ 个作业 $J = \{J_1, J_2, \cdots, J_n\}$，
    每个作业都要在 $m$ 台并行相同的机器集 $M = \{M_1, M_2, \cdots, M_m\}$ 上非抢占执行。
    每个作业有一个确定的处理时间上界 $p_j$。
    目标是最小化完工时间 $C_{\text{max}}$，
    即所有任务中最后一个完成的任务的完成时间。
\end{defi}

然而在实际问题中，作业的实际完工时间可能需要测试才能得出。由此可以抽象出多处理器调度问题的一个变体
\cite{durr2018scheduling}\cite{durr2020adversarial}\cite{albers2021scheduling}：

\begin{defi}
    \textbf{带测试多处理器调度问题：}一个实例 $I$ 包含一组 $n$ 个作业 $J = \{J_1, J_2, \cdots, J_n\}$，
    每个作业都要在 $m$ 台并行相同的机器集 $M = \{M_1, M_2, \cdots, M_m\}$ 上非抢占执行。
    每个作业带有一个处理时间上界 $u_j$ 和一个测试操作的时长 $t_j$，如果进行测试，作业将得到一个实际运行时长 $p_j$。
    每一个作业 $J_j$ 都可以选择在某台机器上花 $u_j$ 时间运行，或者先花 $t_j$ 时间进行测试，之后在同一台机器上运行 $p_j$ 时间。
    目标是最小化完工时间 $C_{\text{max}}$。
\end{defi}

这类问题广泛存在于制造业、云计算资源分配、物流运输等多个行业背景中。
例如，在制造业中，工厂需要决定将哪些工件分配给哪几台机器进行加工以及加工的先后顺序；
在云计算环境中，需要决定如何高效地为虚拟机分配计算资源。
解决多处理器调度问题对于提高生产效率、降低成本具有重要意义。
针对不同场景下的具体需求，研究者们提出了多种算法来寻找最优解或近似解，
有确定性算法例如启发式算法；
非确定性算法（随机算法）例如遗传算法、模拟退火算法等。

\subsubsection{在线问题和竞争比}

在实际问题中，我们往往不能在一开始就得到所有数据，而只能随着决策的过程逐步获取数据。
这就引出了离线问题、半在线问题和在线问题的概念。

\begin{defi}
    \textbf{离线带测试多处理器调度问题：}
    所有作业在时间零时刻到达，且 $t_j, p_j, u_j$ 全部事先已知。
    此时问题等价于处理时间上界为 $\min(t_j+p_j,u_j)$ 的朴素多处理器调度问题。
\end{defi}

\begin{defi}
    \textbf{半在线带测试多处理器调度问题：}
    所有作业在时间零时刻到达，记作 $P\;|\;t_j,0\leq p_j\leq u_j\;|\;C_{\text{max}}$。
\end{defi}

\begin{defi}
    \textbf{在线带测试多处理器调度问题：}
    调度器需要在作业到达时做出测试决策，并指定机器进行测试或直接执行，
    每个作业在上一个作业的调度决策完成后到达，
    记作 $P \; | \; \text{online}, t_j, 0\leq p_j \leq u_j \; | \; C_{\text{max}}$。
\end{defi}

由于信息的缺失，在一般情况下我们无法设计出能够确定地作出最优决策的算法。
因此只能退而寻求近似算法。
我们用竞争比的概念来描述算法的性能：

\begin{defi}
    \textbf{确定性算法的竞争比：}假设存在一个确定性算法，令 $C(I)$ 表示该算法在实例 $I$ 上产生的完工时间，$C^*(I)$ 表示最优离线调度的完工时间。定义该算法的竞争比为
    \[
        \alpha=\sup_{I} \frac{C(I)}{C^*(I)}, \quad \text{其中} I \text{遍历所有问题实例，}
    \]
    该算法被称为 $\alpha$-竞争算法。
\end{defi}

提升竞争比下界对于设计在线和半在线算法具有重要的研究意义：
它可以为在线算法提供一个性能保障，即使在最不利的情况下，也能保证算法的表现不会太差；
它还有助于指导算法的设计和改进，如果一个在线算法的竞争比已经接近或达到已知的下界，那么进一步优化的空间可能非常有限。

\subsubsection{竞争比下界的现有成果}

\begin{thm}
    \label{thm:bound2}
    对于问题 $P2\mid\text{online}, t_j, 0\leq p_j \leq u_j \mid C_{\text{max}}$，任何确定性算法的竞争比大于 2.2117。\cite{albers2021scheduling}
\end{thm}

\begin{proof}
一个可行的构造方案如下：
定义 $\varphi = \frac{\sqrt{5} + 1}{2}$（事实上，可以定义 $\varphi$ 为 $(1.5, 2)$ 的任意实数。）
令 \(t_i = 1, \forall i\)。有两台机器，令其为 $M_1,M_2$，三个工件为 $J_1,J_2,J_3$。
令 $u_1 = \varphi$，将 $J_1$ 在 $M_1$ 上加工。
\\
\textbf{Case1: }
若对 $J_1$ 测试，此时 $p_1=\varphi$，令 $u_2 = \varphi$。
\\
\textbf{Case1.1: }
若对 $J_2$ 测试，此时 $p_2=\varphi$。
如果将 $J_2$ 放在 $M_1$ 上加工，此时 $C = 2+2\varphi$，而 $C^* = \varphi$，$C/C^* = 2\varphi + 2 / \varphi > 2$。
如果将 $J_2$ 放在 $M_2$ 上加工，令 $u_3 = 2\varphi$，
若 $J_3$ 测试，此时 $p_3 = 2\varphi$，则此时 $C \geq 2+3\varphi$，而 $C^* = 2\varphi$，$C/C^* = 2+3\varphi / 2\varphi > 2$。
若 $J_3$ 不测试，此时 $p_3 = 0$，则此时 $C \geq 1+3\varphi$，而 $C^* = 1 + \varphi$，$C/C^* = 1+3\varphi / 1 + \varphi > 2$。
\\
\textbf{Case1.2: }
若对 $J_2$ 不测试，此时 $p_2=0$。
如果将 $J_2$ 放在 $M_1$ 上加工，此时 $C = 2\varphi + 1$，而 $C^* = \varphi$，$C/C^* = 2\varphi + 1 / \varphi > 2$。
如果将 $J_2$ 放在 $M_2$ 上加工，令 $u_3 = 1 + \varphi$，
若 $J_3$ 测试，此时 $p_3 = 1 + \varphi$，则此时 $C \geq 2+2\varphi$，而 $C^* = 1 + \varphi$，$C/C^* = 2+2\varphi / 1 + \varphi = 2$。
若 $J_3$ 不测试，此时 $p_3 = 0$，则此时 $C \geq 1+2\varphi$，而 $C^* = 2$，$C/C^* = 1+2\varphi / 2 > 2$。
\\
\textbf{Case2: }
若不对 $J_1$ 测试，此时 $p_1 = 0$，令 $u_2 = \varphi$。
\\
\textbf{Case2.1: }
若对 $J_2$ 测试，此时 $p_2=\varphi$。
如果将 $J_2$ 放在 $M_1$ 上加工，此时 $C = 1+2\varphi$，而 $C^* = \varphi$，$C/C^* = 2\varphi + 1 / \varphi > 2$。
如果将 $J_2$ 放在 $M_2$ 上加工，令 $u_3 = 1+\varphi$，
若 $J_3$ 测试，此时 $p_3 = 1+\varphi$，则此时 $C \geq 2+2\varphi$，而 $C^* = 1+\varphi$，$C/C^* = 2+2\varphi / 1+\varphi = 2$。
若 $J_3$ 不测试，此时 $p_3 = 0$，则此时 $C \geq 1+2\varphi$，而 $C^* = 2$，$C/C^* = 1+2\varphi / 2 > 2$。
\\
\textbf{Case2.2: }
若对 $J_2$ 不测试，此时 $p_2=0$。
如果将 $J_2$ 放在 $M_1$ 上加工，此时 $C = 2\varphi$，而 $C^* = 1$，$C/C^* = 2\varphi/ 1> 2$。
如果将 $J_2$ 放在 $M_2$ 上加工，令 $u_3 = 1 + \varphi$，
若 $J_3$ 测试，此时 $p_3 = 1 + \varphi$，则此时 $C \geq 2+2\varphi$，而 $C^* = 1 + \varphi$，$C/C^* = 2+2\varphi / 1 + \varphi = 2$。
若 $J_3$ 不测试，此时 $p_3 = 0$，则此时 $C \geq 1+2\varphi$，而 $C^* = 2$，$C/C^* = 1+2\varphi / 2 > 2$。


\end{proof}

对于所有测试操作时间都为单位时间的问题 $P\;|\;\text{online}, t_j=1,0\leq p_j \leq u_j\;|\; C_{\text{max}}$：
当只有一台机器时，Dühr等\cite{durr2018scheduling}\cite{durr2020adversarial}提出，
当 $u_j \leq \varphi := \frac{\sqrt{5}+1}{2}$ 时，对作业 $j$ 进行测试，可以得到 $\varphi$-竞争算法；
或者以概率 $f(u_j) = \max \left(0, \frac{u_j(u_j-1)}{u_j(u_j-1)+1}\right)$ 概率对作业进行测试，
可以得到 $\frac43$-竞争的随机化算法。论文\cite{albers2021explorable}，这两种算法是最优的，
即 $\varphi$ 是确定性算法的竞争比下界，$\frac43$ 是任何随机化算法的期望竞争比下界。
当有 $m\geq 2$ 台机器时，存在 $\varphi(2-\frac1m)$-竞争算法~\cite{graham1966bounds}。
论文\cite{albers2021scheduling} 中提到了，对于任何确定性算法，竞争比下界为 $2$。
该下界的证明使用了两台机器、三个工件来构造最坏实例，具体构造方法可以参考定理\ref{thm:bound2} 的证明。
另外，在 Gong 的论文~\cite{gong2023randomized}中，进一步证明了任何确定性算法的竞争比下界为 2.2117；
同时还提出了一种确定性算法集成的随机化算法，其期望竞争比为 $\frac{3\varphi+3\sqrt{13-7\varphi}}{4}\approx 2.1839$。    

    
\subsection{本研究的意义和目的}

多处理器调度问题作为一个重要的组合优化问题，其在实际生产环境中具有广泛的应用场景，如工业生产和资源分配等领域。
带测试的多处理器调度问题引入了相同的工作的不同处理方式（一种未知效果的新处理手段），并以提高整体系统的效率为目标，同样有着重要的研究意义。

目前在线带测试多处理器调度问题竞争比下界还有较大的提升空间。
现有的研究主要集中在机器数量、工作数量较少的情况下，使用手动构造最坏情况来分析竞争比下界，
但对于更一般的情形，特别是当 $m \geq 3, n\geq 4$ 时，现有的竞争比下界仍有改进余地。

通过引入计算机辅助方法，利用程序设计方法更高效地构建和分析决策树，可以扩大搜索范围，有希望进一步提高竞争比下界。