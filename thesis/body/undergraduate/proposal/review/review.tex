\cleardoublepage
\newrefsection
\chapter{文献综述}

\section{背景介绍}

\subsection{多处理器调度问题}

\subsubsection{问题的背景与基本概念}

多处理器调度问题（Multiprocessor Scheduling Problem）的研究始于计算机系统中对计算资源的有效利用。
早期的计算机系统多为单核处理器，任务的执行通常由操作系统进行单核调度。
随着多核处理器的普及，计算任务可以在多个处理器上并行执行，从而显著提高计算效率和处理能力。
然而，任务之间可能存在依赖关系，或者每个任务的处理时间不同，如何合理地分配任务到各个处理器，
最大限度地减少完成时间或优化其他目标，成为了多处理器调度问题的核心。

多处理器调度问题涉及在多个处理器之间合理地分配和调度一组作业或任务。任务之间可能是独立的，也可能存在依赖关系，例如某些任务必须在其他任务完成后才能开始。
调度的目标通常包括最小化最大完成时间（Makespan）、最小化任务的平均完成时间、或者最大化系统的吞吐量等。

多处理器调度问题在许多实际应用中都有广泛的应用场景。如：高性能并行计算、实时系统、操作系统需要实时处理多个可并行进行的任务的场景。

我们可以建立这样一个简单的数学模型来描述多处理器调度问题。

\begin{defi}[朴素多处理器调度问题]
    一个实例 $I$ 包含一组 $n$ 个作业 $J = \{J_1, J_2, \cdots, J_n\}$，
    每个作业都要在 $m$ 台并行相同的机器集 $M = \{M_1, M_2, \cdots, M_m\}$ 上非抢占执行。
    每个作业有一个确定的处理时间上界 $p_j$。
    目标是最小化完工时间 $C_{\text{max}}$，
    即所有任务中最后一个完成的任务的完成时间。
\end{defi}

多处理器调度问题有很多变种。例如：最小化任务的完成时间之和、最小化任务的等待时间之和、在限制时间内最大化完成任务的数量等。
还有一些变种问题是任务之间存在一些依赖关系，某些任务必须在其他任务完成之后才能开始。
而“非抢占执行”的含义是每个任务只要开始进行就不能中断，
与之相对的是“抢占执行”，即任务可以中断并立即切换为另一个任务开始执行。

多处理器调度问题是一个 NPC 问题，即不存在多项式复杂度的确定性求解算法。
目前研究者们已经设计出确定性算法如启发式搜索，
非确定性算法如遗传算法、模拟退火算法等。

\subsubsection{带测试的多处理器调度问题}

带测试的多处理器调度问题（Testing Multiprocessor Scheduling Problem）是多处理器调度问题的一个扩展，
其中除了通常的任务调度外，还需要进行额外的测试步骤。
这些测试步骤用于评估任务的特性（如任务的处理时间、执行顺序等），从而帮助调度器更准确地做出调度决策。
与传统的调度问题不同，带测试调度问题需要在优化任务调度的同时考虑测试操作的开销和影响。

带测试的多处理器调度问题一般包含两个重要元素：测试阶段和调度阶段。
在测试阶段，系统会对任务进行某些形式的检测或预处理（如任务的处理时间、执行顺序等）。
这些测试通常需要消耗时间和计算资源，因此测试的时间需要纳入整个调度优化过程中。

我们可以从上面的实际问题中抽象出一个数学模型：

\begin{defi}[带测试多处理器调度问题]
    一个实例 $I$ 包含一组 $n$ 个作业 $J = \{J_1, J_2, \cdots, J_n\}$，
    每个作业都要在 $m$ 台并行相同的机器集 $M = \{M_1, M_2, \cdots, M_m\}$ 上非抢占执行。
    每个作业带有一个处理时间上界 $u_j$ 和一个测试操作的时长 $t_j$，如果进行测试，作业将得到一个实际运行时长 $p_j$。
    每一个作业 $J_j$ 都可以选择在某台机器上花 $u_j$ 时间运行，或者先花 $t_j$ 时间进行测试，之后在同一台机器上运行 $p_j$ 时间。
    目标是最小化完工时间 $C_{\text{max}}$。
\end{defi}

当 $t_j=0$ 时，问题就被归约为朴素多处理器调度问题。因此，带测试多处理器调度问题也至少是 NPC 问题，不存在多项式时间复杂度的算法。

\subsection{在线、半在线问题和竞争比}

\subsubsection{在线、半在线带测试多处理器调度问题}

在线和半在线多处理器调度问题是多处理器调度领域中的两个重要分支。
它们在任务到达时机和调度决策上有所不同，主要涉及如何在信息不完全的情况下，合理调度多个处理器以优化系统性能。
随着多核处理器和并行计算的普及，在线和半在线调度问题在实际应用中有着广泛的影响。

\begin{defi}[在线带测试多处理器调度问题]
    当一个任务到达时，调度器只能根据当前的信息进行调度，而无法对未来的任务做出预测。
    因此调度器需要在每个任务到达时就立即决定其处理器分配和执行顺序。
\end{defi}

\begin{defi}[半在线带测试多处理器调度问题]
    介于在线和离线调度问题之间。
    在半在线调度中，调度器可以在任务到达之前得知全部的 $t_i$ 和 $u_i$，但只有在花费 $t_i$ 进行测试之后才可得知 $p_i$。
\end{defi}

与离线算法不同，在线算法无法在一开始就拥有全部输入数据，而是必须随着输入的逐步到来，作出即时决策。
由于无法预知未来的输入数据，在线算法通常面临一个重要问题：如何在信息不完全的情况下做出近似最优的决策。

\subsubsection{竞争比}

为了衡量在线算法的表现，竞争比（Competitive Ratio）是一个关键的概念。它用于比较在线算法的性能与最佳离线算法（或最优算法）在同样问题中的表现差异。

\begin{defi}
    在线算法的竞争比是一个用于度量其性能的度量值。它定义为在线算法执行的最坏情况性能与离线算法执行的最优性能之间的比值。
    具体来说，假设有一个在线调度问题，其实例为 $I$，并记所有实例的集合为 $\mathcal{I}$，定义

    \begin{itemize}
        \item $C(I)$ 是某个离线算法的最优解，即假设我们能够提前知道所有任务的输入，可以通过全局优化来得到的最优解。
        \item $C^*(I)$ 是在线算法在最坏情况下的解。
    \end{itemize}
    则在线算法的竞争比 $\alpha$ 可以表示为
    \[
        \alpha = \sup_{I\in \mathcal{I}} \dfrac{C(I)}{C^*(I)}
    \]
\end{defi}

竞争比总是不小于 1 的，其实际意义在于：
\begin{enumerate}
    \item 衡量在线算法的优劣：竞争比为评估在线算法的性能提供了一个标准。它告诉我们，在最坏的情况下，在线算法的表现相比于最优解有多差。例如，某些算法的竞争比是常数（如3-竞争），这意味着无论输入数据如何变化，算法的执行时间或完成度始终不会超过最优解的3倍。
    \item 适应性与实时性：在线算法的竞争比越低，说明它能在实时情况下做出更接近最优的决策。例如，在云计算和数据流处理等实时计算中，能够提供一个低竞争比的在线调度算法，对于高效利用计算资源、减少延迟至关重要。
    \item 算法的鲁棒性：在面对不同类型的输入时，竞争比高的算法可能在某些场景下表现不佳。通过研究竞争比，我们能够了解在不同场景下算法的鲁棒性，进而选择更适合特定应用的算法。
\end{enumerate}

\subsubsection{竞争比下界}

在线算法的竞争比下界是指在特定问题中，任何在线算法在最坏情况下的性能相对于最优解的比例所能达到的最小值。
了解这一下界具有重要的理论意义，因为它为我们提供了一个不可逾越的性能界限，帮助我们理解在线算法的最佳表现。
具体来说，如果一个问题的竞争比下界是 $\alpha_0$，则意味着无论我们如何设计在线算法，算法在最差情况下的表现都至少是最优解的 $\alpha$ 倍。

研究一个问题的竞争比下界有时是比研究它的具体算法更有效的。具体来说，它可以
\begin{enumerate}
    \item 揭示一个问题在最坏情况下的不可逾越的性能界限。
    \item 帮助评估算法的实际应用性能：竞争比下界表示了在线算法在最坏情况中的最大劣化程度，而通过与实际算法的对比，我们可以判断一个在线算法是否能在实际应用中达到一个“可接受”的水平。
    \item 为算法设计提供指导：了解竞争比下界有助于为在线算法的设计提供理论依据。如果某个问题的竞争比下界较高，那么即使在设计过程中对算法进行大量优化，期望算法的性能会接近最优解也是不现实的。相反，如果下界较低，那么设计一个接近最优的在线算法是可能的。
\end{enumerate}

\section{国内外研究现状}

我们在本文中研究完全在线的多处理器调度与测试问题~\cite{durr2018scheduling,durr2020adversarial,albers2021explorable,albers2021scheduling}，
并从随机化算法的角度进行研究。多处理器调度~\cite{garey1979computers}是最早的已知 NP 难组合优化问题之一，在过去几十年中得到了广泛研究。
多处理器调度的一个实例 \( I \) 包含一组 \( n \) 个作业 \( J = \{J_1, J_2, \dots, J_n\} \)，
每个作业都要在一组 \( m \) 台并行的相同机器 \( M = \{M_1, M_2, \dots, M_m\} \) 上非抢占地执行，
目标是最小化最大完工时间 \( C_{\text{max}} \)，即最大作业完成时间。与经典设置不同的是，在调度与测试中，
每个作业 \( J_j \) 都有一个处理时间上界 \( u_j \)，并且有一个长度为 \( t_j \) 的测试操作，
但其处理时间 \( p_j \) 直到作业被测试后才会揭示。作业 \( J_j \) 可以在其中一台机器上执行 \( u_j \) 时间，或者选择先进行测试，测试时间为 \( t_j \)，然后立即执行 \( p_j \) 时间。若所有作业都在时间零到达，则多处理器调度与测试是一个半在线问题，表示为 \( P | t_j, 0 \leq p_j \leq u_j | C_{\text{max}} \)。本文研究的是完全在线问题，其中作业按顺序到达，在作业到达时需要做出测试决策，并且指定测试和/或执行的机器，表示为 \( P | \text{online}, t_j, 0 \leq p_j \leq u_j | C_{\text{max}} \)。显然，半在线是完全在线的特例，在这两种情况下，调度器都应该利用已知的作业信息，在作业到达时决定是否进行测试，以便最好地平衡由于未知处理时间所消耗的总时间。

给定一个多项式时间的确定性算法，针对半在线或完全在线问题，令 \( C(I) \) 为该算法在实例 \( I \) 上产生的最大完工时间，
而 \( C^*(I) \) 为最优离线调度的最大完工时间。算法的性能通过竞争比来衡量，定义为 \( \sup_I \{ C(I) / C^*(I) \} \)，
其中 \( I \) 遍历所有问题实例，算法称为 \( \sup_I \{ C(I) / C^*(I) \} \)-竞争的。切换到随机化算法时，
我们相应地收集其在实例 \( I \) 上的期望最大完工时间 \( E[C(I)] \)，该随机化算法称为 \( \sup_I \{ E[C(I)] / C^*(I) \} \)-竞争的。
对于在线问题，随机化算法有时可以更好地处理不确定性，从而导致比最好的确定性算法更低的期望竞争比。
我们为 \( P | \text{online}, t_j, 0 \leq p_j \leq u_j | C_{\text{max}} \) 提出了这样的一个随机化算法，
并且进一步证明，当只有两台机器时，其期望竞争比严格小于任何确定性算法已证明的竞争比下界。
在我们的问题中，作业处理是非抢占的。

在文献中，研究人员还考虑了抢占式作业处理~\cite{durr2018scheduling,durr2020adversarial,albers2021explorable,albers2021scheduling}，
其中任何测试或执行操作都可以被中断并稍后恢复，或者考虑了更为受限的测试抢占式变体~\cite{albers2021scheduling}，
在该变体中，已测试作业的测试和执行操作是非抢占的，但执行操作不必立即跟随测试操作，且不一定发生在同一台机器上。
此外，我们的目标是最小化最大完工时间 \( C_{\text{max}} \)，即最小最大目标；而另一个重要目标是最小化总作业完成时间，
或者最小和目标，这也是受到了许多研究的关注~\cite{durr2018scheduling,durr2020adversarial,albers2021scheduling}。


\subsection{全在线问题研究进展}

现有的针对完全在线问题 \( P | \text{online}, t_j, 0 \leq p_j \leq u_j | C_{\text{max}} \) 的近似算法，无论是确定性算法还是随机化算法，都不多。
我们首先区分一个特殊的情况，其中所有的测试操作时间均为单位时间，即对于每个作业 \( J_j \)，有 \( t_j = 1 \)，我们称之为均匀测试情况~\cite{durr2018scheduling,durr2020adversarial,albers2021scheduling}，
表示为 \( P | \text{online}, t_j = 1, 0 \leq p_j \leq u_j | C_{\text{max}} \)。
注意，在一般的测试情况下，测试时间可以是任何非负值。
当只有一台机器时，机器上的作业处理顺序与最大完工时间无关。
这表明完全在线问题和半在线问题是相同的。第一组结果是关于半在线均匀测试问题 \( P_1 | t_j = 1, 0 \leq p_j \leq u_j | C_{\text{max}} \)，
由 D¨urr 等人~\cite{durr2018scheduling,durr2020adversarial}提出。
他们提出，当 \( u_j \geq \varphi = \frac{\sqrt{5} + 1}{2} \) 时测试作业 \( J_j \)，或者以概率 \( f(u_j) = \max \left( 0, \frac{u_j(u_j - 1)}{u_j(u_j - 1) + 1} \right) \) 测试它，
从而得到了一个确定性的 \( \varphi \)-竞争算法和一个期望的 4/3 竞争算法。
令 \( r_j = \frac{u_j}{t_j} \)；Albers 和 Eckl~\cite{albers2021explorable}将上述两种算法扩展到一般测试情况下 \( P_1 | t_j, 0 \leq p_j \leq u_j | C_{\text{max}} \)，
即当 \( r_j \geq \varphi \) 时测试作业 \( J_j \)，或者以概率 \( f(r_j) \) 测试它，
分别达到了相同的竞争比和期望竞争比。作者们~\cite{durr2018scheduling,durr2020adversarial,albers2021explorable}证明了这两种算法是最优的，即 \( \varphi \) 是任何确定性算法的竞争比下界，
而 4/3 是任何随机化算法的期望竞争比下界，这一结果由 Yao 原理~\cite{yao1977probabilistic}得出。 

当至少有两台机器时，完全在线问题比半在线问题更为一般。Albers 和 Eckl~\cite{albers2021scheduling}提出了在列表调度规则~\cite{graham1966bounds}中测试作业 \( J_j \)，
即当 \( r_j \geq \varphi \) 时，按照该规则将每个作业分配到最空闲的机器上进行处理（可能是测试后执行）。他们证明了这样的算法是 \( \varphi(2 - \frac{1}{m}) \)-竞争的，
且该分析是紧的，其中 \( m \) 是机器的数量。他们还证明了，即使在均匀测试情况下 \( P | \text{online}, t_j = 1, 0 \leq p_j \leq u_j | C_{\text{max}} \) 中，
任何确定性算法的竞争比下界为 2~\cite{albers2021scheduling}，并且对于两台机器的一般测试情况 \( P_2 | \text{online}, t_j, 0 \leq p_j \leq u_j | C_{\text{max}} \)，
即当只有两台机器时，其下界为 2.0953，这一结果也稍微更好~\cite{albers2021scheduling}。

\subsection{半在线问题研究进展}

当只有一个机器时，半在线问题与全在线问题等价。

当至少有两台机器时，因为所有作业都在时间零到达，
因此调度器可以利用所有已知的 \( u_j \) 和 \( t_j \) 值，不仅用于作业测试决策，
还可以形成某些作业处理顺序，以更好地减少最大完工时间。事实上，这正是 Albers 和 Eckl ~\cite{albers2021scheduling} 在一般测试情况下提出的开创性所谓 SBS 算法的情况，
该算法在机器数量趋向无穷大时为 3.1016-竞争算法。对于均匀测试情况，Albers 和 Eckl ~\cite{albers2021scheduling} 还提出了一个 3-竞争算法，
并给出了对于任何确定性算法的竞争比下界 \( \max\{\varphi, 2 - \frac{1}{m}\} \)。

上述两个竞争比在一般和均匀测试情况下分别由 Gong 和 Lin ~\cite{gong2021improved} 改进为 2.9513 和 2.8081，
最新的竞争比是 Gong 等人~\cite{gong2023randomized} 分别提出的 2.8019 和 2.5276。

为了证明竞争比下界 \( 2 - \frac{1}{m} \)，Albers 和 Eckl ~\cite{albers2021scheduling} 提出了一个 \( P | t_j = 1, 0 \leq p_j \leq u_j | C_{\text{max}} \) 的实例，
迫使任何确定性算法对所有作业进行测试。这意味着该下界不仅适用于任何确定性算法的竞争比，也适用于任何随机化算法的期望竞争比，
依据 Yao 原理 ~\cite{yao1977probabilistic}。此外，\( 2 - \frac{1}{m} \) 的下界因此适用于完全在线均匀测试问题 \( P | \text{online}, t_j = 1, 0 \leq p_j \leq u_j | C_{\text{max}} \) 中任何随机化算法的期望竞争比。

\subsection{其他相关工作}

Dürr 等人 ~\cite{durr2018scheduling,durr2020adversarial} 为单机均匀测试问题 \( P_1 | t_j = 1, 0 \leq p_j \leq u_j | \sum_j C_j \) 提出了一个期望竞争比为 1.7453 的随机化算法，
该算法按均匀随机顺序测试待测作业。他们还证明了期望竞争比的下界为 1.6257。
Albers 和 Eckl~\cite{albers2021explorable} 为一般测试情况 \( P_1 | t_j, 0 \leq p_j \leq u_j | \sum_j C_j \) 设计了一个随机化算法，
其中作业 \( J_j \) 根据比率 \( r_j \) 使用一个相当复杂的概率函数进行测试；该算法的期望竞争比为 3.3794。

回顾经典在线多处理器调度问题 \( P | \text{online} | C_{\text{max}} \) 的最先进的随机化算法，
其中作业依次到达，处理时间 \( p_j \) 在作业 \( J_j \) 到达时揭示，并且在到达时必须无条件地分配作业到某台机器上执行，
以最小化最大完工时间。众所周知，对于这个问题，从第一个确定性算法列表调度 ~\cite{graham1966bounds} 的竞争比 2 到当前最好的 1.9201~\cite{fleischer2000line}，
经历了很长时间的改进。对于每个在线近似算法，性能分析中最具挑战性的一部分是精确估计最优离线最大完工时间。
三个最典型的下界是 \( \frac{1}{m} \sum_{j=1}^n p_j \)（平均机器负载）、\( \max_{j=1}^n p_j \)
（最大的作业处理时间）和 \( p[m] + p[m+1] \)，其中 \( p[j] \) 是所有作业中的第 \( j \) 大处理时间。
Albers ~\cite{albers2002randomized} 证明，如果只使用上述三个下界，则任何确定性算法的竞争比在 \( m \) 趋于无穷大时都不能小于 1.919。

Albers ~\cite{albers2002randomized} 提出了一个期望竞争比为 1.916 的随机化算法，并且在性能分析中仅使用了上述三个下界来估计最优离线最大完工时间。
更详细地说，Albers 提出了两个确定性算法 \( A_0 \) 和 \( A_1 \)，并提议以 0.5 的概率执行每个算法。
作者表明，如果期望最大完工时间与这三个下界相比过大，即 \( A_0 \) 和 \( A_1 \) 都产生了较大的最大完工时间，
那么在实例中会有许多大作业，使得最优离线最大完工时间无法太小。

这种由常数数量的确定性算法组成的随机化算法被称为“几乎随机化算法”~\cite{reingold1994randomized}，它利用其优秀的组件算法，
在至少一个组件算法表现良好时，它能够表现良好，而如果没有任何组件算法表现良好，那么最优离线最大完工时间也会远离下界。
这个设计思想已被用于逼近许多其他优化问题，并取得了突破性的成果，例如其他调度问题 \cite{seiden2003barely, 9} 和 \( k \)-服务器问题~\cite{bartal2000randomized}。
事实上，对于在线多处理器调度问题 \( P | \text{online} | C_{\text{max}} \)，在 ~\cite{albers2002randomized} 之前，
Seiden ~\cite{seiden2003barely} 修改了 Bartal 等人 ~\cite{bartal1992new} 和 Seiden ~\cite{seiden2000online} 的非几乎随机化算法，这些算法将当前作业分配给两台负载最小的机器之一，
并以一定的概率运行，变成了几乎随机化算法，这是一个 \( k \) 个确定性算法的均匀分布，其中 \( k \) 是算法内要创建的调度的数量，
并且选择足够大以保证期望竞争比。尽管这种方法对小 \( m \) （特别是 \( m \leq 7 \)）有效，
Albers ~\cite{albers2002randomized} 观察到 ~\cite{bartal1992new, seiden2000online, seiden2003barely} 中算法的分析方法在一般的大 \( m \) 情况下不起作用，
随后提出了基于仅两个确定性算法的新几乎随机化算法。

\subsection{存在问题}

现有的针对全在线问题的竞争比下界的研究主要还停留在特殊情况（$m=1$）和小范围情况（$m\leq 2,n\leq 3$）。
研究方法也局限在人工构造博弈决策树，当决策树的层数更深（对应 $n$ 更大）或点数更多（对应 $m$ 更大）时，人工构造就已经很难奏效。
事实上，对于 $m\geq 3,n\geq 4$ 的情形，现有的研究都只能仿照 $m=2,n=3$ 的构造方式尝试构造较坏情况的数据，
这导致目前的竞争比下界和竞争比上界（即目前已经存在的在线算法的竞争比）仍有较大差距。

\section{研究展望}

由上可见，竞争比下界仍可能有较大的提升空间。
因此设计一个通用的建立博弈搜索树的算法是有必要的。
借助计算机的强大算力，我们可以扩大搜索范围，发现人力无法观察到的极端数据，进一步提升竞争比下界。

\newpage
\begingroup
    \linespreadsingle{}
    \printbibliography[title={参考文献}]
\endgroup